$date
	Thu Jan 25 17:36:54 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module RV32_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module DUT $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 # writeback [31:0] $end
$var wire 1 $ mux_select_top $end
$var wire 32 % mux_in_a [31:0] $end
$var wire 32 & immediate [31:0] $end
$var wire 32 ' dmem_out [31:0] $end
$var wire 1 ( WB_sel $end
$var wire 1 ) RW $end
$var wire 32 * PC_Top [31:0] $end
$var wire 32 + PCP4_Top [31:0] $end
$var wire 32 , Instr [31:0] $end
$var wire 1 - Controller_WE $end
$var wire 5 . Controller_ALU [4:0] $end
$var wire 32 / ALU_res [31:0] $end
$var wire 32 0 ALU_in2 [31:0] $end
$var wire 32 1 ALU_in1 [31:0] $end
$var reg 1 2 write $end
$scope module ALU $end
$var wire 5 3 control [4:0] $end
$var wire 32 4 alu_slt [31:0] $end
$var wire 32 5 B [31:0] $end
$var wire 32 6 ALU_result [31:0] $end
$var wire 32 7 A [31:0] $end
$upscope $end
$scope module Data_memory $end
$var wire 32 8 A_mem [31:0] $end
$var wire 1 ! clk $end
$var wire 1 ) MemRW $end
$var wire 32 9 DataIP [31:0] $end
$var wire 32 : D_read [31:0] $end
$upscope $end
$scope module Instruction_memory $end
$var wire 1 " rst $end
$var wire 32 ; RD [31:0] $end
$var wire 32 < A [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 = PCP4 [31:0] $end
$var reg 32 > PC [31:0] $end
$upscope $end
$scope module PC_adder $end
$var wire 32 ? PC_add [31:0] $end
$var wire 32 @ PCP4_add [31:0] $end
$upscope $end
$scope module controller $end
$var wire 3 A funct3 [2:0] $end
$var wire 7 B funct7 [6:0] $end
$var wire 32 C instr [31:0] $end
$var wire 7 D opcode [6:0] $end
$var wire 5 E rd [4:0] $end
$var wire 5 F rs1 [4:0] $end
$var wire 5 G rs2 [4:0] $end
$var wire 1 ( WB_sel $end
$var wire 1 ) MemRW $end
$var wire 1 $ Imm_mux_SEL $end
$var wire 5 H ALU_control [4:0] $end
$var reg 1 - RegWE $end
$upscope $end
$scope module immediate_gen $end
$var wire 32 I Instr [31:0] $end
$var wire 12 J inst_imm [11:0] $end
$var wire 32 K imm [31:0] $end
$upscope $end
$scope module mux $end
$var wire 32 L b [31:0] $end
$var wire 1 $ sel $end
$var wire 32 M c [31:0] $end
$var wire 32 N a [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 32 O a [31:0] $end
$var wire 32 P b [31:0] $end
$var wire 1 ( sel $end
$var wire 32 Q c [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 5 R AddA [4:0] $end
$var wire 5 S AddB [4:0] $end
$var wire 5 T AddD [4:0] $end
$var wire 32 U DataD [31:0] $end
$var wire 1 - WE $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 V DataB [31:0] $end
$var wire 32 W DataA [31:0] $end
$var reg 5 X index [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b1 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b100 @
b0 ?
b0 >
b100 =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
12
b0 1
b0 0
b0 /
b0 .
1-
b0 ,
b100 +
b0 *
1)
0(
b0 '
b0 &
b0 %
0$
b0 #
0"
1!
$end
#50
0!
#100
1!
#150
b1111 .
b1111 3
b1111 H
b1 4
b1100 #
b1100 Q
b1100 U
b1000 &
b1000 K
b1000 L
1$
b1000 0
b1000 5
b1000 M
b1100 /
b1100 6
b1100 8
b1100 O
b1000 J
b101 %
b101 9
b101 N
b101 V
b100 1
b100 7
b100 W
b1000 E
b1110 G
b10 F
b100011 D
b1110 S
b10 R
b1000 T
b111000010000010000100011 ,
b111000010000010000100011 ;
b111000010000010000100011 C
b111000010000010000100011 I
0!
1"
#200
b1100 /
b1100 6
b1100 8
b1100 O
b1100 .
b1100 3
b1100 H
b1000 0
b1000 5
b1000 M
b101 '
b101 :
b101 P
b101 #
b101 Q
b101 U
1$
0)
1(
b1100 %
b1100 9
b1100 N
b1100 V
b10 A
b1100 E
b1000 G
b11 D
b1000 S
b1100 T
b100000010010011000000011 ,
b100000010010011000000011 ;
b100000010010011000000011 C
b100000010010011000000011 I
b1000 +
b1000 =
b1000 @
b100 *
b100 <
b100 >
b100 ?
1!
#250
0!
#300
b101 /
b101 6
b101 8
b101 O
b0 .
b0 3
b0 H
b0 4
b0 0
b0 5
b0 M
b0 '
b0 :
b0 P
b101 #
b101 Q
b101 U
b0 &
b0 K
b0 L
b0 J
1)
0(
b0 %
b0 9
b0 N
b0 V
b101 1
b101 7
b101 W
b0 A
b0 G
b1100 F
b10011 D
b0 S
b1100 R
b1100000011000010011 ,
b1100000011000010011 ;
b1100000011000010011 C
b1100000011000010011 I
b1100 +
b1100 =
b1100 @
b1000 *
b1000 <
b1000 >
b1000 ?
1!
#350
0!
#400
bx .
bx 3
bx H
bx 0
bx 5
bx M
x$
bx '
bx :
bx P
bx #
bx Q
bx U
bx &
bx K
bx L
bx /
bx 6
bx 8
bx O
b0x 4
bx J
x)
x(
bx %
bx 9
bx N
bx V
bx 1
bx 7
bx W
bx B
bx A
bx E
bx G
bx F
bx D
bx S
bx R
bx T
bx ,
bx ;
bx C
bx I
b10000 +
b10000 =
b10000 @
b1100 *
b1100 <
b1100 >
b1100 ?
1!
#450
0!
#500
b10100 +
b10100 =
b10100 @
b10000 *
b10000 <
b10000 >
b10000 ?
1!
#550
0!
#600
b11000 +
b11000 =
b11000 @
b10100 *
b10100 <
b10100 >
b10100 ?
1!
#650
0!
#700
b11100 +
b11100 =
b11100 @
b11000 *
b11000 <
b11000 >
b11000 ?
1!
#750
0!
#800
b100000 +
b100000 =
b100000 @
b11100 *
b11100 <
b11100 >
b11100 ?
1!
#850
0!
#900
b100100 +
b100100 =
b100100 @
b100000 *
b100000 <
b100000 >
b100000 ?
1!
#950
0!
#1000
b101000 +
b101000 =
b101000 @
b100100 *
b100100 <
b100100 >
b100100 ?
1!
#1050
0!
